#!/bin/python3
'''
Improved version of the cli-chat client for waksmemes. Original client here:

https://github.com/ehrenjn/cli-chat

rtx is intended to better organized from a code-base persepctive than the 
original. Additionally it is intended to (eventually) have a better UI.
rtx is target for unix and python3. If you want a different platform try
the original client.

(c) Zak Nafziger 2018
'''

import requests
import json
import hashlib
from Crypto import Random
from Crypto.Cipher import AES
import base64
import datetime
import sys
import os
import urllib
import ast

# utilities ===================================================================
class AESCipher:
	# basic class to provide AES cryptography, shamelessly ripped from 
	# stack exchange:
	# https://stackoverflow.com/questions/12524994/encrypt-decrypt-using-py
	# crypto-aes-256

	def __init__(self, key):
		self.bs = 32
		self.key = hashlib.sha256(key.encode()).digest()

	def encrypt(self, raw):
		raw = self._pad(raw)
		iv = Random.new().read(AES.block_size)
		cipher = AES.new(self.key, 
			AES.MODE_CBC, iv)
		return base64.b64encode(iv + cipher.encrypt(raw))

	def decrypt(self, enc):
		enc = base64.b64decode(enc)
		iv = enc[:AES.block_size]
		cipher = AES.new(self.key, 
			AES.MODE_CBC, iv)
		unpadded = self._unpad(
			cipher.decrypt(enc[AES.block_size:]))
		return unpadded.decode('utf-8', errors = 'ignore')

	def _pad(self, s):
		return s + (self.bs - len(s)%self.bs)*\
			chr(self.bs - len(s)%self.bs)

	@staticmethod
	def _unpad(s):
		return s[:-ord(s[len(s)-1:])]

def color(string, color):
	colors = {
		'red': "\x1b[1;31m",
		'green': "\x1b[1;32m",
		'yellow': "\x1b[1;33m",
		'blue': "\x1b[1;34m",
		'purple': "\x1b[1;35m",
		'cyan': "\x1b[1;36m",
		'stop color' : "\x1b[0m"
		}
	if color not in colors:
		return string
	else:
		return colors[color] + string + colors['stop color']

def merge_dicts(a, b):
	# recursively merge two dictionaries
	# if a key is only in b it is added to a
	# if a key is in both a and b and it points to a dict in both
	#       they are merged
	# otherwise the value of a is used
	for k in b:
		if k not in a:
			a[k] = b[k]
		elif isinstance(a[k], dict) and isinstance(b[k], dict):
			a[k] = merge_dicts(a[k], b[k])
	return a

# recieve chain ===============================================================
def rx(server, room, depth):
	ids_after = 0
	query = {'MAX_MSGS': depth, 'id': {'min': ids_after + 1}}
	reqs = requests.post(server + room, json = query)
	raw = reqs.content.decode('utf-8')
	msg_list = json.loads(raw)
	msg_list.reverse()
	
	return msg_list

def decrypt(msg_list, key=None):
	for msg in msg_list:
		encryption = msg.get('encrypted', False)
		cipher_text = base64.b64decode(msg.get('msg',
			'')).decode('utf-8')
		if (encryption != False) and (key != None):
			cipher = AESCipher(key)
			msg['msg'] = cipher.decrypt(cipher_text)
		else:
			msg['msg'] = cipher_text
	return msg_list

def unpack(msg_list, unpack_settings=None):
	if unpack_settings == None:
		unpack_settings = {'':''}
	topen = unpack_settings.get('topen', '[')
	tclose = unpack_settings.get('tclose', ']')
	sep = unpack_settings.get('sep', ':')
	tfmt = unpack_settings.get('tfmt', '%H:%M')

	arranged_msg_list = []
	for msg in msg_list:
		timestamp = msg['time']
		text = msg['msg']
		encryption_flag = msg.get('encrypted', False)
		
		if 'settings' in msg:
			raw_settings = base64.b64decode(
				msg['settings']).decode('utf-8')
			pack_settings = json.loads(raw_settings)

		name = pack_settings.get('name', msg['ip'])
		name_color = pack_settings.get('color', '')

		if encryption_flag == True:
			colon_color = unpack_settings.get('encrypted_color',
							'red')
		else:
			colon_color = unpack_settings.get('unencrypted_color', 
							None)
		
		arranged_msg = topen
		arranged_msg += datetime.datetime.fromtimestamp(
			timestamp).strftime(tfmt)
		arranged_msg += (tclose + " ")
		arranged_msg += color(name, name_color)
		arranged_msg += color(sep, colon_color)
		arranged_msg += " "
		arranged_msg += text

		arranged_msg_list.append(arranged_msg)

	return arranged_msg_list

# transmit chain ==============================================================
def encrypt(text_to_encrypt, key=None):
	encryption = False
	if key is not None:
		cipher = AESCipher(key)
		encrypted_text = cipher.encrypt(text_to_encrypt)
		encrypted_text = encrypted_text.decode('utf-8')
		encryption = True
	else:
		encrypted_text = text_to_encrypt

	return (encrypted_text, encryption)

def pack(data_to_pack, pack_settings=None):
	text_to_pack = data_to_pack[0]

	text_to_pack = base64.b64encode(bytes(text_to_pack,
		encoding = 'utf-8'))

	if pack_settings != None:
		pack_settings = base64.b64encode(
			bytes(json.dumps(pack_settings),encoding = 'utf-8'))

		packed_data = {
			'msg': text_to_pack.decode('utf-8'),
			'settings': pack_settings.decode('utf-8'),
			'encrypted': data_to_pack[1]
			}
	else:
		packed_data = {
			'msg' : text_to_pack.decode('utf-8'),
			'encrypted' : data_to_pack[1]
			}

	return packed_data

def tx(server, room, msg):
	requests.post(server + room + '!post', json = msg)

# recieve/transmit frontends ==================================================
def push(server, room, msg, key=None, pack_settings=None):
	encrypted_msg = encrypt(msg, key)
	packed_msg = pack(encrypted_msg, pack_settings)
	tx(server, room, packed_msg)

def pull(server, room, depth, key=None, unpack_settings=None):
	encrypted_msgs = rx(server, room, depth)
	plain_msgs = decrypt(encrypted_msgs, key)
	pretty_msgs = unpack(plain_msgs, unpack_settings)
	return pretty_msgs

def config_from_defaults():
	# our default global settings
	global_settings = {
		'waksmemes.x10host.com' : {
			'url' : 'http://waksmemes.x10host.com/mess/?',
			'main' : None
			},
		'server' : 'waksmemes.x10host.com',
		'room' : 'main',
		'depth' : 24
	}
	return global_settings

def config_from_file(global_settings):
	# attempt to load a user config file
	sys.path.append(os.path.join(os.path.expanduser('~'), '.config'))
	try:
		from rtx import config
	except ImportError:
		pack_settings = None
		unpack_settings = None

	# merge the user's global settings with the defaults
	# possible exception if the user no global settings
	try:
		global_settings = merge_dicts(config.global_settings, \
			global_settings)
	except AttributeError:
		pass
	
	# attempt to load un/pack settings from config
	try:
		pack_settings = config.pack_settings
	except AttributeError:
		pack_settings = None;
	try:
		unpack_settings = config.unpack_settings
	except AttributeError:
		unpack_settings = None;

	return global_settings, pack_settings, unpack_settings

def config_from_cmd(global_settings, pack_settings, unpack_settings):
	# The available command line arguments are:
	arguments = {
		'--url=' : None,
		'--room=' : None,
		'--key=' : None,
		'--depth=' : None,
		'--pack_settings=' : None,
		'--unpack_settings=' : None,
		'--mode=' : None,
		'--write_config=' : None
	}

	# parse fill the arguments dict
	for arg in sys.argv:
		for arg_name in arguments:
			if arg.startswith(arg_name):
				arguments[arg_name] = arg[len(arg_name):]

	cmd_global_settings = {}

	# parse the server's url if given
	if arguments['--url='] != None:
		parsed_uri = urllib.parse.urlparse(arguments['--url='])
		server = '{uri.netloc}'.format(uri=parsed_uri)
	else:
		server = None

	# TODO: get smarter and fix this...
	# this builds a new global_settings from cmd args, failing over to
	# defaults that were passed in global_settings, in a way that makes
	# contextual sense. essentially there are three properties:
	# url, room, key,
	# there are 8 ways the above info can be passed so this block just
	# goes through all 8 building the settings dict
	# it sucks cause its completely non-general and requires knowledge
	# about significance (in a MSB sense) of the above properties
	if server != None:
		cmd_global_settings[server] = {}
		cmd_global_settings['server'] = server

		if arguments['--room='] != None:
			room = arguments['--room=']
			cmd_global_settings['room'] = room
			cmd_global_settings[server][room] = \
				arguments['--key=']
		else:
			room = global_settings['room']
			cmd_global_settings[server][room] = \
				arguments['--key=']
	else:
		server = global_settings['server']
		if arguments['--room='] != None:
			room = arguments['--room=']
			if room in global_settings[server]:
				if arguments['--key='] != None:
					global_settings[server][room] = \
						arguments['--key=']
			else:
				global_settings[server][room] = \
					arguments['--key=']
		else:
			if arguments['--key='] != None:
				room = global_settings['room']
				global_settings[server][room] = \
					arguments['--key=']

	# merge in the settings table we just built
	global_settings = merge_dicts(cmd_global_settings, global_settings)

	# un/pack settings are flat and potentially very long, so we just let
	# the user specifify a dictionary and then interperate it literally
	# this could maybe be more elegant...
	# then we merge the dicts we got (if any).
	# this just explodes in flames if the user passes malformed dicts,
	# because this function is already a mess and I'm not writing a python
	# parser
	if arguments['--pack_settings='] != None:
		cmd_pack_settings = \
			ast.literal_eval(arguments['--pack_settings='])
		pack_settings = merge_dicts(cmd_pack_settings,
			pack_settings)
	if arguments['--unpack_settings='] != None:
		cmd_unpack_settings = \
			ast.literal_eval(arguments['--unpack_settings='])
		unpack_settings = merge_dicts(cmd_unpack_settings,
			unpack_settings)

	return global_settings, pack_settings, unpack_settings

def main():
	global_settings = config_from_defaults()
	
	global_settings, pack_settings, unpack_settings = \
		config_from_file(global_settings)
	
	global_settings, pack_settings, unpack_settings = \
		config_from_cmd(
			global_settings,
			pack_settings,
			unpack_settings
		)

	server_name = global_settings['server']
	room = global_settings['room']
	depth = global_settings['depth']

	server = global_settings[server_name]['url']
	key = global_settings[server_name][room]

	pretty_msgs = pull(server, room, depth, key, unpack_settings)
	for m in pretty_msgs:
		print(m)
	
	new_msg = input(">")
	push(server, room, new_msg, key, pack_settings)

if __name__ == "__main__":
	main()
