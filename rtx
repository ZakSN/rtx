#!/bin/python3
'''
Improved version of the cli-chat client for waksmemes. Original client here:

https://github.com/ehrenjn/cli-chat

rtx is intended to better organized from a code-base persepctive than the 
original. Additionally it is intended to (eventually) have a better UI.
rtx is target for unix and python3. If you want a different platform try
the original client.

(c) Zak Nafziger 2018
'''

import requests
import json
import hashlib
from Crypto import Random
from Crypto.Cipher import AES
import base64
import datetime
import sys
import os

# utilities ===================================================================
class AESCipher:
	# basic class to provide AES cryptography, shamelessly ripped from 
	# stack exchange:
	# https://stackoverflow.com/questions/12524994/encrypt-decrypt-using-py
	# crypto-aes-256

	def __init__(self, key):
		self.bs = 32
		self.key = hashlib.sha256(key.encode()).digest()

	def encrypt(self, raw):
		raw = self._pad(raw)
		iv = Random.new().read(AES.block_size)
		cipher = AES.new(self.key, 
			AES.MODE_CBC, iv)
		return base64.b64encode(iv + cipher.encrypt(raw))

	def decrypt(self, enc):
		enc = base64.b64decode(enc)
		iv = enc[:AES.block_size]
		cipher = AES.new(self.key, 
			AES.MODE_CBC, iv)
		unpadded = self._unpad(
			cipher.decrypt(enc[AES.block_size:]))
		return unpadded.decode('utf-8', errors = 'ignore')

	def _pad(self, s):
		return s + (self.bs - len(s)%self.bs)*\
			chr(self.bs - len(s)%self.bs)

	@staticmethod
	def _unpad(s):
		return s[:-ord(s[len(s)-1:])]

def color(string, color):
	colors = {
		'red': "\x1b[1;31m",
		'green': "\x1b[1;32m",
		'yellow': "\x1b[1;33m",
		'blue': "\x1b[1;34m",
		'purple': "\x1b[1;35m",
		'cyan': "\x1b[1;36m",
		'stop color' : "\x1b[0m"
		}
	if color not in colors:
		return string
	else:
		return colors[color] + string + colors['stop color']

def merge_dicts(a, b):
	# recursively merge two dictionaries
	# if a key is only in b it is added to a
	# if a key is in both a and b and it points to a dict in both
	#       they are merged
	# otherwise the value of a is used
	for k in b:
		if k not in a:
			a[k] = b[k]
		elif isinstance(a[k], dict) and isinstance(b[k], dict):
			a[k] = merge_dicts(a[k], b[k])
	return a

# recieve chain ===============================================================
def rx(server, room, depth):
	ids_after = 0
	query = {'MAX_MSGS': depth, 'id': {'min': ids_after + 1}}
	reqs = requests.post(server + room, json = query)
	raw = reqs.content.decode('utf-8')
	msg_list = json.loads(raw)
	msg_list.reverse()
	
	return msg_list

def decrypt(msg_list, key=None):
	for msg in msg_list:
		encryption = msg.get('encrypted', False)
		cipher_text = base64.b64decode(msg.get('msg',
			'')).decode('utf-8')
		if (encryption != False) and (key != None):
			cipher = AESCipher(key)
			msg['msg'] = cipher.decrypt(cipher_text)
		else:
			msg['msg'] = cipher_text
	return msg_list

def unpack(msg_list, unpack_settings=None):
	if unpack_settings == None:
		unpack_settings = {'':''}
	topen = unpack_settings.get('topen', '[')
	tclose = unpack_settings.get('tclose', ']')
	sep = unpack_settings.get('sep', ':')
	tfmt = unpack_settings.get('tfmt', '%H:%M')

	arranged_msg_list = []
	for msg in msg_list:
		timestamp = msg['time']
		text = msg['msg']
		encryption_flag = msg.get('encrypted', False)
		
		if 'settings' in msg:
			raw_settings = base64.b64decode(
				msg['settings']).decode('utf-8')
			pack_settings = json.loads(raw_settings)

		name = pack_settings.get('name', msg['ip'])
		name_color = pack_settings.get('color', '')

		if encryption_flag == True:
			colon_color = unpack_settings.get('encrypted_color',
							'red')
		else:
			colon_color = unpack_settings.get('unencrypted_color', 
							None)
		
		arranged_msg = topen
		arranged_msg += datetime.datetime.fromtimestamp(
			timestamp).strftime(tfmt)
		arranged_msg += (tclose + " ")
		arranged_msg += color(name, name_color)
		arranged_msg += color(sep, colon_color)
		arranged_msg += " "
		arranged_msg += text

		arranged_msg_list.append(arranged_msg)

	return arranged_msg_list

# transmit chain ==============================================================
def encrypt(text_to_encrypt, key=None):
	encryption = False
	if key is not None:
		cipher = AESCipher(key)
		encrypted_text = cipher.encrypt(text_to_encrypt)
		encrypted_text = encrypted_text.decode('utf-8')
		encryption = True
	else:
		encrypted_text = text_to_encrypt

	return (encrypted_text, encryption)

def pack(data_to_pack, pack_settings=None):
	text_to_pack = data_to_pack[0]

	text_to_pack = base64.b64encode(bytes(text_to_pack,
		encoding = 'utf-8'))

	if pack_settings != None:
		pack_settings = base64.b64encode(
			bytes(json.dumps(pack_settings),encoding = 'utf-8'))

		packed_data = {
			'msg': text_to_pack.decode('utf-8'),
			'settings': pack_settings.decode('utf-8'),
			'encrypted': data_to_pack[1]
			}
	else:
		packed_data = {
			'msg' : text_to_pack.decode('utf-8'),
			'encrypted' : data_to_pack[1]
			}

	return packed_data

def tx(server, room, msg):
	requests.post(server + room + '!post', json = msg)

# recieve/transmit frontends ==================================================
def push(server, room, msg, key=None, pack_settings=None):
	encrypted_msg = encrypt(msg, key)
	packed_msg = pack(encrypted_msg, pack_settings)
	tx(server, room, packed_msg)

def pull(server, room, depth, key=None, unpack_settings=None):
	encrypted_msgs = rx(server, room, depth)
	plain_msgs = decrypt(encrypted_msgs, key)
	pretty_msgs = unpack(plain_msgs, unpack_settings)
	return pretty_msgs

def config_from_defaults():
	# our default global settings
	global_settings = {
		'waksmemes' : {
			'url' : 'http://waksmemes.x10host.com/mess/?',
			'main' : None
			},
		'server' : 'waksmemes',
		'room' : 'main',
		'depth' : 24
	}
	return global_settings

def config_from_file(global_settings):
	# attempt to load a user config file
	sys.path.append(os.path.join(os.path.expanduser('~'), '.config'))
	try:
		from rtx import config
	except ImportError:
		pack_settings = None
		unpack_settings = None

	# merge the user's global settings with the defaults
	# possible exception if the user no global settings
	try:
		global_settings = merge_dicts(config.global_settings, global_settings)
	except AttributeError:
		pass
	
	# attempt to load un/pack settings from config
	try:
		pack_settings = config.pack_settings
	except AttributeError:
		pack_settings = None;
	try:
		unpack_settings = config.unpack_settings
	except AttributeError:
		unpack_settings = None;

	return global_settings, pack_settings, unpack_settings

def config_from_cmd(global_settings, pack_settings, unpack_settings):
	return global_settings, pack_settings, unpack_settings

def main():
	global_settings = config_from_defaults()
	
	global_settings, pack_settings, unpack_settings = \
		config_from_file(global_settings)
	
	global_settings, pack_settings, unpack_settings = \
		config_from_cmd(
			global_settings,
			pack_settings,
			unpack_settings
		)

	server_name = global_settings['server']
	room = global_settings['room']
	depth = global_settings['depth']

	server = global_settings[server_name]['url']
	key = global_settings[server_name][room]

	pretty_msgs = pull(server, room, depth, key, unpack_settings)
	for m in pretty_msgs:
		print(m)
	
	new_msg = input(">")
	push(server, room, new_msg, key, pack_settings)


if __name__ == "__main__":
	main()
